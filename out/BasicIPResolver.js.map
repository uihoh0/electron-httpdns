{"version":3,"sources":["../src/BasicIPResolver.ts"],"names":[],"mappings":";;;;;;;AAMc,MAAgB,eAAhB,CAA+B;AACzC,EAAA,WAAA,CAAY,OAAZ,EAA4C;AAWpC,SAAA,OAAA,GAAyB,EAAzB;AAVJ,SAAK,QAAL,GAAgB,EAAhB;;AACA,QAAG,CAAC,OAAJ,EAAY;AACR;AACH;;AACD,QAAG,KAAK,CAAC,OAAN,CAAc,OAAd,CAAH,EAA0B;AACtB,WAAK,OAAL,GAAe,KAAK,OAAL,CAAa,MAAb,CAAoB,OAApB,CAAf;AACA;AACH;;AACD,SAAK,OAAL,CAAa,IAAb,CAAkB,OAAlB;AACH;;AAIM,QAAM,OAAN,CAAc,IAAd,EAA4B,OAA5B,EAAmD;AACtD,UAAM,KAAK,GAAG,KAAK,QAAL,CAAc,IAAd,CAAd;;AACA,QAAI,KAAJ,EAAW;AACP,aAAO,KAAK,CAAC,CAAD,CAAZ;AACH;;AACD,UAAM,GAAG,GAAG,MAAM,KAAK,WAAL,CAAiB,IAAjB,EAAuB,OAAO,IAAI,KAAK,OAAvC,CAAlB;;AACA,QAAI,CAAC,GAAD,IAAQ,GAAG,CAAC,MAAJ,GAAa,CAAzB,EAA4B;AACxB,aAAO,KAAP;AACH;;AACD,SAAK,QAAL,CAAc,IAAd,IAAsB,GAAtB;AACA,WAAO,GAAG,CAAC,CAAD,CAAV;AACH;;AACM,QAAM,gBAAN,CAAuB,SAAvB,EAAsD,IAAtD,EAAkE;AACrE,WAAO,UAAU,SAAS,KAAK,IAAI,EAAnC;AACH;;AACS,QAAM,WAAN,CAAkB,IAAlB,EAAgC,OAAhC,EAAiD;AACvD,UAAM,QAAQ,GAAkB,CAAC,OAAO,IAAI,EAAZ,EAAgB,KAAhB,CAAsB,CAAtB,CAAhC;;AACA,QAAI,QAAQ,CAAC,MAAT,GAAkB,CAAtB,EAAyB;AACrB,aAAO,IAAP;AACH;;AACD,IAAA,QAAQ,CAAC,IAAT,CAAc,MAAM,IAAI,CAAC,MAAL,KAAgB,GAAhB,GAAsB,CAAC,CAAvB,GAA2B,CAA/C;;AACA,UAAM,SAAS,GAAG,QAAQ,CAAC,GAAT,EAAlB;;AACA,QAAI,GAAG,GAAG,MAAM,KAAK,gBAAL,CAAsB,SAAtB,EAAiC,IAAjC,CAAhB;;AACA,QAAI,CAAC,GAAL,EAAU;AACN,aAAO,IAAP;AACH;;AACD,QAAI;AACA,aAAO,MAAM,KAAK,OAAL,CAAa,GAAb,CAAb;AACH,KAFD,CAEE,OAAO,CAAP,EAAU;AACR;AACA,aAAO,MAAM,KAAK,WAAL,CAAiB,IAAjB,EAAuB,QAAvB,CAAb;AACH;AACJ;;AA/CwC,C","sourcesContent":["\nexport interface IPArray extends Array<string> { }\n\nexport interface HttpDnsConfig {\n    type: string\n}\nexport default abstract class BasicIPResolver {\n    constructor(servers?: Array<string> | string) {\n        this.ipsCache = {}\n        if(!servers){\n            return\n        }\n        if(Array.isArray(servers)){\n            this.servers = this.servers.concat(servers)\n            return\n        }\n        this.servers.push(servers)\n    }\n    private servers: Array<string> = []\n    public ipsCache: { [index: string]: Array<string> }\n    abstract async request(url: string): Promise<IPArray | null | undefined>\n    public async resolve(host: string, servers?: Array<string>): Promise<string | false | null> {\n        const cache = this.ipsCache[host];\n        if (cache) {\n            return cache[0]\n        }\n        const ips = await this.loopResolve(host, servers || this.servers);\n        if (!ips || ips.length < 1) {\n            return false\n        }\n        this.ipsCache[host] = ips;\n        return ips[0]\n    }\n    public async createRequestUrl(dnsServer: string | undefined, host: string): Promise<string> {\n        return `http://${dnsServer}/?${host}`\n    }\n    protected async loopResolve(host: string, servers?: IPArray):Promise<IPArray | null | undefined> {\n        const _servers: Array<string> = (servers || []).slice(0);\n        if (_servers.length < 1) {\n            return null\n        }\n        _servers.sort(() => Math.random() > 0.5 ? -1 : 1);\n        const dnsServer = _servers.pop();\n        let url = await this.createRequestUrl(dnsServer, host);\n        if (!url) {\n            return null;\n        }\n        try {\n            return await this.request(url)\n        } catch (e) {\n            // console.log('error:', e)\n            return await this.loopResolve(host, _servers)\n        }\n    }\n}"],"sourceRoot":""}
